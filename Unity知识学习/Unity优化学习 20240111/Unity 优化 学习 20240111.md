# Unity 优化学习  2024/01/11

## 一、有哪些优化指标

项目的优化直接影响着应用的使用体验。首先我们需要选择一些指标来作为优化目标：

- 运行时指标：帧率FPS是我们最常接触，也是体验最明显的性能指标。一个项目15帧基本上是不能用的状态，30帧勉强能用，能做到60帧则会让用户体验有极大的提高。另一方面，运行时内存大小也十分重要，考虑到移动平台内存条件有限，过大的内存占用很容易造成杀后台和进程崩溃。
- 离线指标：Unity为了尽可能适配所有类型的资产，提供了丰富繁杂的资产导入设置。然而为了普适性，其中很多默认设置存在性能、存储大小、内存大小等方面的浪费，因此如何优化好一个资产的离线设置也对项目很有帮助。另一方面，减小包体大小对于项目的分发也有所帮助，毕竟没有人愿意动不动就下1G的APP。

## 二、离线资产优化

### 1.  资产检查工具 UPR Asset Checker

欲先行其事，必先利其器。

如果你没有丰富的开发经验，很难去判断一个资产设置的合不合理，而且人工检查资产也费时费力。因此这里就需要用到自动化的资产检查工具[UPR AssetChecker](https://upr.unity.cn/instructions/assetchecker)

将工具下载到你的电脑，并打开命令行执行以下命令，最终会在assetcheck.exe所在目录生成一个检查报告**rule_report.yaml**：

```
assetcheck.exe generate-config
assetcheck.exe --project=<unity_project_path>
```

当然，这个报告肯定不能用肉眼去读，因此我们还需要在[UPR官网](https://upr.unity.cn/projects)创建一个项目，并导入我们生成的rule_report.yaml文件，如下所示：

![img](C:\Users\shxz\Desktop\Unity学习\Learning\Unity知识学习\Unity优化学习 20240111\Picture\1)

![img](C:\Users\shxz\Desktop\Unity学习\Learning\Unity知识学习\Unity优化学习 20240111\Picture\2)

最终打开这个报告，我们就可以看到详细的资源设置情况，其中包含音频、纹理、3D模型等资源的分析，并会给出相应的优化建议。虽然不是所有的优化建议都合适，但值得我们作为优化参考。下面以音频资源优化为例。

#### 1.1 音频设置优化

一般我们下载到的原始音频资源都是无损的wav格式，因此体积较大。然而在绝大部分情况下，我们的APP不需要高精度的音频质量，并且可以做一些针对性的格式修改：

- 立体声转为单声道：一些以Player为中心播放的音频其实不存在立体声的效果，因此可以把立体声通道去除，强制转为单声道音频。
- 压缩格式：wav保留了最完整的音频细节但是体积巨大，因此我们可以选择Ogg或者Mp3格式，在保留90%的细节同时极大的压缩文件体积。
- 音频采样率：通常电脑端的音频都是44K采样率，然而对于手机有限的处理性能和音响性能来说，44K通常是不必要的，改为22K能在不怎么影响音质的同时缩小一半的音频体积。

![img](C:\Users\shxz\Desktop\Unity学习\Learning\Unity知识学习\Unity优化学习 20240111\Picture\3)

## 三、运行时性能优化

### 1. 帧率分析工具 Unity Profiler

同样，在针对运行时性能优化之前，我们也需要找到APP的性能瓶颈在哪。Unity自带一个好用的帧率分析工具Unity Profiler (Unity编辑器--Window--Analysis--Profiler)，可以一览CPU、GPU、C#代码、UI等模块的性能占用情况。

![img](C:\Users\shxz\Desktop\Unity学习\Learning\Unity知识学习\Unity优化学习 20240111\Picture\4)

### 2.  内存分析工具 Memory Profiler

另外Unity还提供了一个内存分析工具 Memory Profiler。其用热力图的方式展示了运行时内存占比，便于我们参考优化相关资源和堆对象的管理。

![img](C:\Users\shxz\Desktop\Unity学习\Learning\Unity知识学习\Unity优化学习 20240111\Picture\5)

### 3. C#代码注意事项

#### 3.1 string——最常见的堆对象

首先，C#的对象内存分布分为两种：一种是便宜好用的临时栈对象，分配和释放几乎没有代价。另一种则是需要垃圾回收的堆对象，其会产生较大的性能消耗，我们在写C#代码的时候应该尽量减少堆对象的产生。而string就是堆对象类型，因此我们要**尽量减少没必要的string对象生成**。比如可以将每个函数里面重复使用的string改到类里面。

另外需要注意的是，**string是不可修改的。因此有一个很常见的string使用误区如下：**

```C#
string result= “this” + “is” + “a” + name;//name=="test"
```

虽然这条代码看起来是一次把四个字符串拼成了一个string，但实际上它执行了3次拼接操作，生成了三个字符串：

```C#
this is
this is a
this is a test
```

因此，本来“this is a test”只有11字节，这样操作下来却生成了24字节的堆对象垃圾，造成了双倍的内存开销。那我们要怎么去拼接字符串呢？使用$字符串或者`StringBuilder`类：

```C#
string result=$"this is a {name}";
```

另外string标准库还有两个操作有效率上的坑点：

-  `String.Equals(str1 , str2, [StringComparison.`**`Ordinal`**`])`：默认情况下，string.Equals效率很慢，需要加入参数Ordinal强制使用字节比较模式，效率能够快10倍。
- 正则表达式搜索：`Regex.Match`每次搜索会产生至少5000字节的堆垃圾，消耗巨大。如果要使用正则表达式最好分别构造模式串和匹配串，也能将内存消耗缩小到1/10。

#### 3.2 Unity API注意事项

- `Gameobject.Find(“something”)`是一个写起来很方面，但是效率很低的API。它会在整个场景中搜索所有的对象进行匹配。想一下每次要在100000个阀门里找一个名字叫“FMAABB”的阀门。因此尽量不要使用`Gameobject.Find`。绝大部分Find都可以通过编辑器的预置序列化来实现，实在不行还能使用`FindWithTag`来替代。
- 尝试自己接管各个`MonoBehaviour`的回调如`Update`。Unity管理回调时是通过native层跟踪并唤醒C#层的Update方法，因此会存在两层之间的通信开销。即使是空的`Update(){}`也一样有开销。因此可以尝试不走`MonoBehaviour`的结构，定义一个普通的C#类和Update方法，并由自己的`UpdateManager`类来调用它们的Update。

> ​    *`UpdateManager`可以用委托+观察者模式来实现，但要小心C#委托在添加或移除订阅者时，会完全复制整套订阅者，和string一样。*

- Unity中大部分返回array的API都是复制,因此注意不要重复调用访问器，如下：

>   *以下代码会生成3份vertices。*

```C#
x = mesh.vertices[i].x;
y = mesh.vertices[i].y;
z = mesh.vertices[i].z;
```

### 4. UGUI

UI面板看起来很简单，但实际上也是性能消耗的一个大头。

- **UGUI所有组件都是在透明通道绘制：**有时候我们会偷懒没有关闭旧的UI，而直接把新的UI覆盖在了上面。然而这样由于UGUI都是在透明通道，因此依旧会对被挡住的UI进行渲染操作，但又完全看不到，浪费性能。
- **UGUI是合批渲染的**：UGUI的渲染和场景模型渲染一样，都会努力进行合批处理，以减少CPU的drawcall和GPU状态的改变。因此我们需要尽量避免打断UGUI的合批操作。UGUI的合批是以Canvas为单位的，而Canvas下有任意UI的改变都会造成整个Canvas重新合批，因此需要考虑将动态元素和静态元素分离到不同的Canvas下。
- **减少UI输入事件的检查**：在接受到输入信号如点击、拖动时，UGUI会遍历整个屏幕上所有的可交互UI对象，并检查它们的位置是否在输入信号的位置。类似于Gameobject.Find，整个遍历操作也是浪费性能的，因此对于不需要交互的UI组件，我们应该关闭Raycast Target或Interactable选项，减少遍历对象。
- **减少Layout或AutoSize自动布局的改动**：UGUI提供了方便的自动布局功能，但是这些布局是要Unity通过CPU算出来的，每次对UI的相关改动都会导致layout的rebuild。另外特别注意TMP的AutoSize功能，其通过遍历迭代多个size来找到最合适的字体大小，效率极低，尽可能少用或者避免频繁更新autosize的TMP组件。

### 5. 渲染优化

除去渲染算法上的改动，我们能在渲染上做的优化大致分为两类：

- 渲染剔除：减少渲染对象。
- 渲染合批：减少CPU drawcall和GPU状态改变。

#### 5.1 渲染剔除

由于玩家视野有限，很多物体即使渲染出来玩家也根本看不到，是白白浪费性能。因此可以尽量减少玩家视野之外的物体渲染，来减轻GPU压力：

- 相机视椎体剔除：这一点Unity已经默认做了。但是我们依然能够根据玩家所处场景，去动态修改相机视椎体大小，比如在房间内时使视椎体更小一点，充分发挥视椎体剔除的作用。
- Camera的Layer Mask和Layer Distance：根据情况，我们可以定制Camera渲染的层级。同样例如在房间内，可以只显示InHouse Layer。而Layer Distance则可以用来定制每个Layer的剔除距离，覆盖视椎体远平面的剔除。
- LOD：根据玩家距离，动态决定物体网格细节，以便节省一些不必要的模型顶点数和面数。推荐一个简单易上手的插件[NanoLOD](https://assetstore.unity.com/packages/tools/modeling/nanolod-automatic-lods-193314)
- 遮挡剔除：如果一个物体被挡在其他物体后面完全看不到，我们也没必要去渲染它。不过需要CPU去判断物体的遮挡关系，因此实际上是用CPU换GPU
- 像素剔除：即使渲染物体数不变，我们也可以从shader上挤出一些像素剔除来节省shader计算，例如选择是否开启背面剔除、Early Z。

另外从更宏观的层面上，如果场景灯光数过多，会造成前向渲染的压力，可以考虑改成延迟渲染或者Forward+。

#### 5.2 渲染合批

由于GPU是状态机模式运行，并且CPU和GPU中间存在着通信交换的开销，因此在渲染物体不变的情况下，减少CPU和GPU的drawcall通信，减少GPU状态的切换，也能够有效提升性能。（通常是节省CPU的时间）

一方面我们可以对资源提前做好合批：

- 网格合批：使用C# CombineMesh或者3D软件提前将进行网格层次的合并。
- 纹理合批：使用Sprite Atlas和TextureArray对纹理进行打包管理。
- Shader属性合批：使用Material Property Block对同材质但有不同属性的大量物体进行属性修改。

另一方面，Unity也提供了一些运行时渲染合批的方法：

- 静态合批：对于标记为Static的物体都可以参与到静态合批中。不过需要一批最多顶点数为64000，并且合并后的超大网格也会影响到一些剔除判定。
- 动态合批：对任何对象，Unity都可以提供运行时动态合批，但这需要消耗CPU即时计算，不一定会带来性能提升。并且限制条件也很多。

> *静态合批和动态合批都会额外生成一份合并网格，导致网格内存占用翻倍。*

- 其他运行时合批技术：SRP Batching、GPU instance

### 6. 资源加载优化

另外一个很影响使用体验的点就是资源加载。一方面不合理的资源加载会导致读屏时间过长，另一方面不当的内存资源管理也会导致内存的浪费。

举个例子：默认情况下，我们会把一个重复使用的模型做成Prefab资源，然后在其他代码中引用并Instantiate实例使用。然而在Instantiate之前，实际上由于Prefab的引用，我们会在APP启动时将prefab先加载到内存，之后再等待Instantiate。这样会造成启动加载时间过长，以及Instantiate之前不必要的内存占用。

![img](C:\Users\shxz\Desktop\Unity学习\Learning\Unity知识学习\Unity优化学习 20240111\Picture\6)

常见的导致启动时加载资源的原因有三类：

- 场景预置资源：例如已经把房子、树木等摆在场景中了。那么在启动加载场景时，必须要先把房子、树木的纹理和模型等资源加载进入内存。
- C#序列化引用：例如我们平常引用的public Gameobject，如果上述的场景预置资源A上挂了一些代码，并且代码引用了一些其他资源B，那么B也会跟随A在启动时加载。
- Resources文件夹：所有放在Resources文件夹的资源都会在启动时加载。Unity建议不要使用Resources文件夹。

那么我们应该怎么改造资源加载呢？使用AssetBundle/Addressable对资源进行按需加载。Addressable是对AssetBundle封装后更简洁易用的API，因此这里介绍(Addressable的使用方法)[https://docs.unity3d.com/Packages/com.unity.addressables@1.21/manual/index.html]

首先需要将资源标记为Addressable，标记之后的路径则是这个资源的key，用于在之后加载资源：

![img](C:\Users\shxz\Desktop\Unity学习\Learning\Unity知识学习\Unity优化学习 20240111\Picture\7)

有了key之后，我们则可以在代码中动态进行资源加载和卸载：

```C#
internal class LoadAddress : MonoBehaviour
{
    public string key;
    AsyncOperationHandle<GameObject> opHandle;

    public IEnumerator Start()
    {
        opHandle = Addressables.LoadAssetAsync<GameObject>(key);
        yield return opHandle;

        if (opHandle.Status == AsyncOperationStatus.Succeeded)
        {
            GameObject obj = opHandle.Result;
            Instantiate(obj, transform);
        }
    }

    void OnDestroy()
    {
        Addressables.Release(opHandle);
    }
}
```

另外考虑到public Gameobject形式的序列化引用在大部分情况下很有用，因此Addressable也提供了一个新的形式public AssetReference，使用方法如下所示：

```C#
internal class LoadAddress : MonoBehaviour
{
    public AssetReference prefab;//和以前一样，在编辑器中拖动预置。

    /// 从Addressable中加载prefab的Asset，并返回实例化的Transform
    private Transform GetInstance(AssetReference prefab)
    {
        AsyncOperationHandle<GameObject> handle = default;
        //已有Asset缓存handle
        if (prefab.Asset != null)
        {
            return Instantiate(((GameObject)prefab.Asset).transform);
        }
        else//没有Asset缓存则加载
        {
            handle = prefab.LoadAssetAsync<GameObject>();
            Transform instance = Instantiate(handle.WaitForCompletion().transform);
            if (instance == null)
            {
                Debug.LogError("场景对象模型未能初始化");
            }
            else
            {
                cache_handles.Add(prefab, handle);
                instance.gameObject.SetActive(true);
            }
            return instance;
        }
    }
}
```

## 四、学习资源补充

 [Unity 优化导论(1).pptx](Unity优化学习 20240111\文件\Unity 优化导论(1).pptx) 

